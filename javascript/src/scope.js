
/**
 * * 스코프
 * ? 말 그대로 범위. 함수,변수 참조될 수 있는 모든 값이 어느 정도 까지 범위
 * ? 에서 참조되는지를 나타내는 굉장히 중요한 모든 언어에서 배워야하는 기본 개념
 * ? 범위를 제대로 이해하지 못한다면 예기치 않은 곳에서 문제가 생길 수 있다.
 */

/** 
  * ! 스코프는 참조 대상 식별자를 찾아내기 위한 규칙입니다. 자바스크립트 만의 규칙으로 범위에 따른
  * ! 식별자를 구분하고 찾습니다.
 */

var glo = "global";
var glo = "glo";

function scope() {
    var glo = "function level scope : var";
    console.log(glo);
}

console.log(glo);
scope();

/** 
 * ? 자바스크립트는 식별자 이름을 중복해서 사용할 수 있다. 그러나 ES6 에서는 이런 문제를 해결하기 위해
 * ? let 변수는 중복선언을 지원하지 않는다.
 * ? 스코프는 중복선언된 식별자를 구별하기 위해 어디에서 선언되었는지에 따라 참조되는 범위를 달리해 구별하게 된다.
 * ? 함수 레벨 스코프를 가지는 var로 선언된 변수는 함수 내에서 선언된 변수는 외부에서 참조할 수 없다.
 * ? 따라서 함수 내부에서 선언된 중복 변수 glo는 외부에 아무런 영향을 끼칠 수 없는 것이다.
 * ! 스코프로 구분할 수 있으나 중복선언은 절대로 피하도록 하자. 식별자 이름은 굉장히 많다.
*/


/** 
 * * 스코프의 구분 -> 대표적인 변수로 설명
 * ? 크게 스코프를 두 가지로 나눌 수 있다.
 * 
 * ? 1. 전역 스코프
 * ? 2. 지역 스코프
*/

/** 
 * * 1. 전역 스코프 
 * ? 전역으로 선언된 변수라는 것은 블록 코드 내에 선언되지 않았다는 의미다.
 * ? 전역으로 선언되었기 때문에 어디에서든 참조할 수 있다.
 * ! 어디에서든 참조가 가능하기 때문에 값이 예기치 못하게 바뀔 수 있다. 조심하자.
*/

var damn = "hey!"; // 전역 스코프 변수

{
    var damn = "ya!"; // 블록 코드 내에 선언된 변수 
    //! var는 함수 레벨 스코프기 때문에 함수가 아닌 블록 코드 내에 선언되어도 전역 스코프가 된다.
    // TODO 함수가 아니라는 의미는 조건문,반복문 에서도 포함이다. 심지어 for문의 조건변수도 전역이다. ;;
}

console.log(damn);


let mitt = "hey!";

{
    let mit = "hey!";
}

//! console.log(mit); 참조할 수 없음 error 가 뜬다. 

// ? let은 ES6에서 나온 기존의 var 변수를 개선해 중복 선언을 막고, 함수 레벨이 아닌
// ? 블록 레벨 스코프를 통해 최소한의 범위로 참조 문제를 최대한 해결할 수 있다.

/** 
 * * 2. 지역 스코프
 * ? 전역이 아닌 지역(함수) 내에서 선언된 변수를 뜻한다. 외부에선 참조할 수 없고
 * ? 함수 레벨이나 블록 레벨이냐에 따라 다르다. 위에서 설명했듯이 var는 함수레벨 let은 블록 레벨이다.
*/

/** 
 * * 지역 스코프의 활용성
 * ? 즉시 실행 함수는(IFFE)는 말 그대로 선언되자마자 바로 실행되는 특징을 갖고 있다.
 * ? 함수 블록을 가지는 자바스크립트의 특정상 독립된 영역 내에서 충돌의 위험 없이 초기화 처리를 해야할 때 
 * ? 유용하게 사용할 수 있다.
*/

(() => {})(); //? 즉시 실행 함수 로직 

/** 
 * * 내부 함수
 * ? 함수 내에서 선언된 함수를 내부 함수라고 하고, 내부 함수는 외부 함수의 변수에 접근할 수 있지만,
 * ? 신기하게도 외부에서는 내부 함수에 접근할 순 없다.
*/

var x = 10;

function foo(){
    var x = 100;
    console.log(x); // ? 100

    function bar(){   // ? 내부함수
        x = 1000; // ? -> 외부 함수 x = 100을 재할당
        console.log(x); //? 1000
    }

    bar();
}
foo(); 
console.log(x); //? 10

// ! 식별자 중복 선언이기 때문에 같은 변수인 거 같지만 다르다. 이래서 중복 선언은 재앙이다.


/**
 * ! 렉시컬 스코프
 * ? 함수를 선언할 때에 스코프는 두 가지로 예상해 볼 수 있다.
 * 
 * * 1. 함수를 호출했을 때의 스코프
 * * 2. 함수를 선언했을 때의 스코프
 * 
 * ? 자바스크립트는 스코프를 결정할 때 2번 방법으로 스코프를 결정하므로,
 * ? 함수 내에서 사용되는 변수에 스코프는 함수가 선언된 장소에서 결정된다.
 * ? 이를 렉시컬 스코프 또는 정적 스코프라고 한다.
 */

var score = 10;

function result() {
    var score = 1000;
    add();
}

function add() {
    console.log(score);
}

result(); // 1000

add(); // 10 

/** 
 * ! 선언된 함수에 위치에 따라 스코프가 결정되기 때문에 add()의 결과는 전역 변수인
 * ! 10의 값을 반환한다.
*/

/** 
 * * 암묵적 전역
 * ? 자바스크립트의 전역 변수는 window객체의 프로퍼티로써 작동하게 되는데,
 * ? 객체의 프로퍼티를 동적으로 할당할 수 있다는 특성 때문에
 * ? 변수를 선언하지 않았음에도, 전역 변수를 참조하게 되면 
 * ? 전역 객체인 window의 프로퍼티를 동적으로 할당해 버리기 때문에 사용할 수 있게 된다. 
 * ! 전역 변수처럼 사용하는 것이다.
*/

console.log(y=30); // ! y 라는 변수를 선언하지 않았음에도 30이 할당되었다.

/** 
 * ! 가독성의 굉장한 문제가 생길 수 있기 때문에 사용을 권장하지 않으며,
 * ! 전역 객체의 프로퍼티 처럼 작동하기 때문에 delete를 통해 삭제할 수 있다.
*/

delete y;

// ? console.log(y); -> not defined

/** 
 * ! 전역 객체의 프로퍼티기 때문에 변수 호이스팅이 발생하지 않습니다.
*/

/** 
 * * 전역변수의 사용을 억제하는 방법 두 가지.
 * ? 전역변수를 남용하면 당연히 파일끼리의 변수 충돌 부분도 있기 때문에 좋지 않다.
 * ? 그러기 위해 사용하는 방법 두 가지가 있다.
*/

/** 
 * * 1. 전역변수 객체를 사용
*/

var lexical = {};

lexical.option = 'option';

console.log(lexical.option);

/** 
 * * 2. 즉시실행함수를 이용한 억제
 * ? 즉시실행함수를 통해 실행되는 함수는 한 번 실행되고, 바로 전역에서 사라지는 특징이 있다.
 * ? 특히 외부 라이브러리간의 변수 충돌을 막아줄 수 있다는 큰 장점이 있다.
*/
