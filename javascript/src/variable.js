
/** 
 * ? 컴퓨터의 연산의 주체는 데이터이며 프로그래머는 이 데이터를 관리하기 위해
 * ? 변수를 사용해 값을 저장하고 참조하며, 값을 연산,평가하며 조건,반복문을 통해
 * ? 데이터의 흐름을 제어하며, 객체와 배열을 통해 데이터를 구조화할 수 있다.
*/

/** 
 * * 자바스크립트의 변수
 * ? 프로그래밍은 컴퓨터에게 명령을 내리는 것이며, 데이터를 저장하게 되면 
 * ? 실제 물리적 장소인 메모리에 그 데이터가 저장된다.
 * ? 실제로 저장된 메모리 상 데이터는 '주소'를 가지게 되며, 이 주소를 알아야
 * ? 데이터에 접근해서 연산을 할 수 있는 것인데, 이 주소값을 사람이 외우고 이해하기엔
 * ? 문제가 있기 때문에 인간이 이해할 수 있는 언어를 통해 각 메모리 주소에 들어있는
 * ? 데이터를 "식별"하기 위한 식별자를 만들었고, 이게 변수다. 
 * TODO 즉 변수는 값의 위치(주소)를 갖고 있는 식별자다. 
*/

/**
 * * 정적 타입과 동적 타입 언어 
 * ? 프로그래밍 언어는 다양하다. JAVA,C,PYTHON 그리고 배우고 있는 자바스크립트
 * ? 까지 컴퓨터를 다루는 분야냐 영역에 따라 강점과 단점이 있는 이 언어들은 프로그래밍
 * ? 의 기본이라 할 수 있는 변수에서도 다른 특징을 가지게 된다.
 * 
 * * 정적 타입
 * ? 자바나 C같은 정적 타입(Static) 언어의 경우 변수를 선언할 때 메모리의 저장될 값
 * ? 에 대한 용량을 할당하는데, 코딩을 할 때도 사전에 어느정도의 용량을 메모리에 할당할건지,
 * ? 지정하고 변수를 선언한다. 예를 들자면
 * 
 * ? int num; 
 * ? 처럼 int -> 4byte 정수를 메모리에 할당하겠다는 의미이고, 용량은 4byte가 된다. 
 * ? 따라서 정적 타입 언어는 변수를 선언 할 때, 메모리가 차지하는 용량도 같이 선언한다. 한 번 선언한 메모릴 용량은 변경할 수 없다. 
 * 
 * * 동적 타입
 * ? 자바스크립트 언어는 대표적인 동적 타입(Dynamic)을 갖고 있다 동적이란 변수 선언 시 따로 메모리 용량을 설정할 필요 없이
 * ? 값이 "할당되는" 과정에서 타입 추론(Type Inference)으로 인해 자동으로 메모리가 결정된다. 따라서 하나의 변수의 여러 타입의 값을 사용할 수 있다. 
 */

 var dynamic = 1; // 여기서 자바스크립트는 배정밀도 64비트 부동소숫점형(자바의 double 형식이라고 생각하면 편하다)을 사용하기 때문에 실수만을 표현한다. 겉보기에는 정수여도 속으로는 실수인 것
 dynamic = 'hello'; // 문자열 데이터 타입
 dynamic = [1,2,3]; // 배열 데이터 타입
 dynamic = { // 객체 프로퍼티와 메서드
    name : 'obj',
    Type : Inference(),
}

function Inference() { // 메서드 함수 (정의만 해놓음)
    
}

/**
 * * 데이터 타입

 * ? 자바스크립트의 데이터 타입은 한정된 메모리 공간을 효율적으로 사용하기 위해 (동적 할당)
 * ? 다양한 데이터를 표현하기 위해 7개의 데이터 타입을 제공합니다.
 * 
 * * 원시 타입 (불변성 데이터 타입)
 * * boolean
 * * null
 * * undefined
 * * number
 * * string
 * * symbol
 * 
 * * 객체 타입 (잘 아시는 객체)
 * * object
 * 
 */

/** 
 * * 원시 타입 
 * ? 원시 타입은 변경 불가능한 불변성을 갖고 있고, pass-by-value(값에 의한 전달) 이다.
 * ? 여기서 변경 불가능 하다는 의미는 이미 메모리에 할당된 리터럴은 절대로 수정할 수 없다는 뜻이다.

 * ! 숫자 타입 (number)
 */
var integer = 23; // 정수
 var double = 23.142; // 실수
 var nagetive = -23; // 음의 정수
 var binary = 0b01000001; //2진수 0b가 2진수 표현을 뜻함
 var octal = 0o101; // 8진수 표현은 0o
 var hex = 0x41; // 16진수 표현은 0x

/**
  * ? 자바스크립트 변수는 다른 언어와 다르게 하나의 숫자 타입만을 사용한다.
  * ? ECMA 표준에 따르면 배정밀도 64비트 부동소수점 형 을 사용한다는데 필자는 잘 모르겠다. 공부해야지..
  * ? 자바스크립트가 사용하는 타입은 모든 수를 실수로 처리하기 때문에 위에 표현된 정수도 겉은 정수여도 속은 실수다. 1 = 1.0
  * ? 2,8,16 진수 리터럴은 메모리에 위에 숫자 타입 형식의 2진수로 저장되고, 따로 데이터 타입을 제공하진 않아 이들 값을 참조할땐 10진수로 해석되 호출된다
  * ? 즉 위에 진수 리터럴들은 출력시 모두 10진수 65이 출력된다. 
  * ? 정수 끼리 나누더라도 실수가 나올 수 있다. 애초에 정수도 실수기 때문이다.
  * 
  * ! 문자열 타입 (string)
  */
var str = 'string'; // 문자열을 표시할 때는 ""나 '' 안의 넣으면 된다. 따옴표를 중복으로 넣고 싶다면 \로 탈출하면 된다. 
str = "string";
str = `my age : ${integer}`;  // ES6 템플릿 문자열로 문자열에 변수를 효율적으로 넣기 위해 만들어진 문자열 

/**  
 * TODO 원시 값의 불변성 
 * ? 자바스크립트의 원시값은 메모리에 한 번 할당되면 그 안에 내용을 바꿀 수 없는 불변성을 갖고 있다.
 */

 var immutable = 6;
 immutable = 7;

/**
 * ? 위에 변수에 처음에 6을 할당하게 되면 타입 추론을 통해 자동으로 메모리 용량을 할당하고 그 안에 6이라는 값을 넣는다
 * ? 할당이 끝난 6은 수정이 불가능 하기 때문에 7이라는 변수를 재할당 할 시 새로운 메모리 공간을 만들어 그 곳에 7을 넣고 그 7을 참조한다.
 * ? 그러기에 6은 더 이상 사용되어 지지 않기 때문에 나중에 가비지 콜렉터가 실행되어 메모리가 해제된다. 
 * * 가비지 콜렉터는 사용되어 지지 않는 메모리를 일정 시간마다 해제 시키는 청소기 역할을 한다.
 * ? 그러나 예외가 있는데 이미 만들어진 메모리에 들어가 있는 6을 다른 변수가 참조하게 될시 새로 만드는 비효율을 막기 위해 재사용이 가능하다. 
 * TODO 이 규칙은 문자열과 숫자 구분없이 적용된다.
 */
var recycle = 6; // 이미 6이 들어간 메모리가 할당 돼 있으니 재활용한다. 


/** 
 * * 유사 배열
 * ? 자바스크립트 문자열은 배열 인덱스를 통해 문자열에 접근할 수 있다.
 * ? 이를 유사배열이라 한다.
 */
console.log(str[0]); // 문제없이 참조할 수 있다.

/** 
 * ! 참조할 수 있으나 변경은 절대 불가능하다. 
 * ! 연산자를 통해 추가하거나 삭제하거나 대문자로 치환하는 것 전부
 * ! 새로운 메모리를 새로 할당하는 재할당이다.
 */

/** 
 * ! 논리 타입 (boolean)
*/

var truth = true;
var liar = false;

/** 
 * ? if와 같은 조건문에서 참과 거짓을 판단해 데이터의 흐름을 제어할 때 사용
 * ? null,undefined,0 모두 false 로 간주된다.
*/


/** 
 * ! undefined
*/

var undef; 

/** 
 * ? 유일한 값인 undefined를 갖고있고 선언 이후 "할당"을 하지 않는 변수에 자바스크립트 엔진이
 * ? 자동으로 undefined 라는 값으로 초기화 시킨다. 
 * ? 여기서 할당은 "=" 을 뜻한다. 말 그대로 값을 넣겠다 라는 뜻. 
 * ? 이 값을 통해 이 변수는 선언만 했다는 걸 알 수 있기에 의도적으로 사용을 자제
*/

/** 
 * ! null
*/

var Null = null; // 자바스크립트는 대,소문자를 구분한다.

/** 
 * ? null 은 의도적으로 이 변수에 값이 없을을 나타내거나, 유효한 값을
 * ? 반환할 수 없을때 null 반환되기도 한다.
*/

/** 
 * ! symbol 
 * ? 여긴 나중에 추가 아직 모자람.
*/


/** 
 * * 객체 타입
 * ? 객체는 원시 타입과 달리 불변성을 가지고 있지 않으며, 자바스크립트는 
 * ? 객체지향인 만큼 자바스크립트를 이루고 있는 것이 객체이며, 원시 타입을 
 * ? 제외한 나머지 값들(배열,함수,정규표현식)은 모두 객체다. 
 * ? pass-by-reference(참조에 의한 전달)을 갖고 있다. 
 * ? 할당 연산자를 통해 전해지는 값은 값 그 자체가 아닌 참조값(주소값) 
*/

/** 
 * * 원시값과 참조값
 * ? 둘의 차이는 할당 연산자를 통해 값을 "어떻게" 넘기냐에 차이인 것 같다.
 * ? 원시값은 단순히 리터럴만 넘기기 때문에 메모리 안에 실제로 저장된 값에 접근할 수 없다. 
 */

var num_one = 5;
var num_two = num_one;
num_two = 7;

console.log(num_one); // 단순히 값만을 넘기기 때문에 one 변수값은 변하지 않는다.

/** 
 * ? 참조값을 넘기는 값(객체 등등)들은 불변성을 가지지 않고 그 메모리에 접근권한을 넘기기 때문에
 * ? 직접 수정할 수 있다.
*/

var obj_one = {
  num : 7,
  str : 'hello',
}

var obj_two = obj_one; // 값만을 넘긴게 아닌 실제 저장된 메모리 주소값을 넘김

obj_two.num = 8; // 접근 연산자를 사용해 프로퍼티 수정

console.log(obj_one); // 값이 수정 돼 있는걸 알 수 있음. 원시값을 제외한 모든 값은 다 저렇게 작동

/**
 * * 변수의 특징 
 * ? 변수는 프로그램에서 사용할 데이터를 참조하여 사용하기 위해 고유의 이름은
 * ? 식별자를 명시한 것이다. 말 그대로 데이터를 식별하기 위함. 
 */

 /** 
  * ! 변수의 선언 키워드 
 */

var score = 60; // 함수 레벨 스코프를 가짐 여기서 스코프는 변수의 유효 범위

for(var i = 0; i < 3; i++) {
  score++;
}

console.log(i);

/** 
 * ? var 키워드는 함수 레벨 스코프를 가지고 있다.
 * ? 여기서 스코프는 변수의 유효 범위를 뜻하며, 함수 레벨 즉 함수 안에서 선언된 변수는 
 * ? 함수 내에서만 사용할 수 있고, 외부에서는 참조할 수 없는 범위를 가진다는 뜻이다.
 * ? 이 스코프의 단점은 함수 외부에서만 선언된다면, 그 변수는 전역 변수가 되버리기 때문에
 * ? 변수의 중복 사용이나, 의도치 않은 참조로 문제를 일으킬 수 있다. 심지어 위의 예시처럼
 * ? for문에 사용된 i변수까지 함수 외에서 선언됐기 때문에, 참조하고 사용할 수 있게 되버린다.
 * ! 스코프의 범위는 좁을수록 좋다.
*/

let average = score / 2; // 블록 레벨 스코프를 가짐 좀 더 좁아진 유효 범위

const pass = 80; // 상수를 지정 , 블록 레벨 스코프를 가짐

{
  let average = score / 3;
  console.log(`block scope: ${average}`);
}

console.log(average);

/** 
 * ? let,const 키워드는 var가 가지는 너무 넓은 유효범위로 인한 문제를
 * ? 해결하기 위해 나왔다. 즉 함수 레벨이 아닌 블록 레벨 스코프를 가지게 된다.
 * ? 즉, 블록 내부에서 선언된 변수를 외부에서 참조할 수 없게 범위를 확실히 줄였다.
 * ? 위의 예시에서 블록 내의 재할당된 average값 과 외부에서 호출한 average이 다른 값이 출력됐다.
 * ? 즉 블록 외부에서 내부를 참조하지 못했다는 것.
 * ? const 는 상수 키워드이다. 
*/

/** 
 * ! 변수 호이스팅 
*/

console.log(hoist);

var hoist = 10;

/** 
 * ? 변수 호이스팅은 모든 선언문이 맨 첫줄에서 실행된 것 처럼 작동하는 것을 뜻한다.
 * ? 예제를 보면 선언되기 이전에 호출했는데도 불구하고, undefined를 호출했다.
 * ? 선언만을 하고 할당을 하지 않았을 시 자바스크립트 엔진이 undefined를 호출하기 때문에
 * ? 선언문이 먼저 이루어 졌다는 걸 알 수 있다. 이처럼 모든 선언문은 선언 되기 이전에 참조할 수 있다.
*/

