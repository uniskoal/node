/** 
 * * 객체
*/

/** 
 * ? 자바스크립트는 객체 기반의 언어이며, 원시타입 값을 제외한 모든 값들은
 * ? 전부 객체이다. 예를 들어 배열,정규표현식,함수가 있다.
*/

/** 
 * * 객체의 표현 방법
*/

var obj = {
    key : "value",
    print : function(text) {
        console.log(text);
    },
}

obj.print("hello"); // 객체의 프로퍼티 호출 .연산자를 사용

/** 
 * ? 객체는 키(key)와 값(value)으로 구성된 프로퍼티(property)들의 집합이다.
 * ? 프로퍼티는 특성이라는 뜻을 가지고 있다. 객체는 현실의 사물이나 사람, 추상적인 개념
 * ? 을 표현하기 위해 특성으로 정의한다.
 * ? 객체에는 자바스크립트에서 사용할 수 있는 모든 값을 사용가능하며, 함수또한 일급 객체이므로, 값처럼 사용할 수 있다.
 * ? 그러기에 위에서 처럼 함수도 값으로 사용할 수 있는데 일반적인 함수와 구분하기 위해서 "행동"을 뜻하는
 * ? 메서드로 부른다.
*/

/** 
 * TODO 객체는 데이터인 프로퍼티와 데이터를 참조하고 사용하는 행동을 의미하는 메소드로 구성된 집합이다.
 * ! 자바스크립트는 다른 언어와는 달리 클래스 상속으로 객체지향을 표현하는 거와 달리
 * ! 프로토타입 기반 상속 객체지향 언어이다. 
 * ! 다른 언어와 특징이 다르지만 자바스크립트 자체도 클래스를 지원하긴 한다.
 */


/** 
  * * 프로퍼티(특성)
  * ? 객체의 특성을 표현하는 프로퍼티는 키와 값으로 구성된다.
  * ? 키 : 값 처럼 사용하며, 프로퍼티 값을 키가 유일하게 식별할 수 있는 식별자 역할을 하게 된다.
  * ? 호출 시에도 키를 사용함.
  * ! 프로퍼티 키 : 빈 문자열을 포함한 모든 문자열과 유일한 식별값을 가지는 Symbol 값
  * ! 프로퍼티 값 : 전부. 일급 객체인 함수도 값으로 사용할 수 있다. 
 */

/** 
  * *  메서드(함수)
  * ? 일급 객체인 함수는 프로퍼티 값으로써 사용할 수 있고, 객체 내의 한정된 함수를 메서드라고 따로 명명한다.
 */

/** 
 * * 객체 생성 방법
 * ? 자바스크립트는 클래스 기반이 아니어서 다른 자바,파이썬과 다르게 클래스로 객체를 생성하지 않았다 ES6 이전까지
 * ? 아직 공부 중으로 프로토타입에 대한 개념이 명확하지 않아 공부중인 본문 그대로를 소개함. 
 * 
 * TODO ECMAScript 6에서 새롭게 클래스가 도입되었다. 프로토타입 기반 프로그래밍은 클래스가 존재하지 않는 
 * TODO 객체지향 프로그래밍 스타일이다. 클래스없이 프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화(정보 은닉) 등의 개념을 구현한다. 
 * TODO 하지만 클래스 기반 언어에 익숙한 프로그래머들은 혼란을 일으킬 수 있으며 자바스크립트를 어렵게 느끼게하는 하나의 장벽처럼 인식되었다. 
 * TODO ES6의 클래스는 기존 프로토타입 기반 객체지향 프로그래밍보다 클래스 기반 언어에 익숙한 프로그래머가 보다 빠르게 학습할 수 있는 단순하고 깨끗한 새로운 문법을 제시하고 있다. 
 * TODO ES6의 클래스가 새로운 객체지향 모델을 제공하는 것이 아니며 클래스도 사실 함수이고 기존 프로토타입 기반 패턴의 문법적 설탕(Syntactic sugar)이다.
 * 
 * ? 핵심은 클래스 상속을 함수를 통해 흉내낸 것이며, 기존 프로토타입 기반 패턴을 사용한다.
 * ! 문법적 설탕은 사용자가 이해하기 편하게 구조가 아닌 디자인 만을 바꾼 것이다.
 * ! 쉽게 표현되면 사용자 입장에서 달달하잖아.
*/

/** 
 * * 객체 생성 방법
 * ? 자바스크립트의 객체 생성 방법은 굉장히 간단하다. 할당 연산을 통해 {}만 넣어주면, 빈 객체의 탄생이다.
 * ? 객체를 할당할 때 초기화를 해놓는 게 일반적인 방법이다.
*/

var emptyObj = {} // 빈 객체의 탄생 언제든지 프로퍼티를 추가할 수 있다. 

emptyObj.property = 1; // 바로 이렇게

console.log(emptyObj); // 완벽

// 사람을 표현한 객체

var person = {
    name : 'Kim Jun Seo',
    gender : 'male',
    age : 23,
    distance : 0,
    walking : function() {
        distance = 10;
    } // 간단하게 걸으면 10 이동하는 단순 코딩 
}

typeof person // object 

/** 
 * * new 연산자를 통해 생성하는 대표적인 방법
 * ? 자바와 같이 클래스 기반 객체지향 언어는 new 연산자와 생성자를 통해 객체를 생성한다.
 * ? 이때 생성된 객체를 인스턴스라고 한다.
*/

var human = new Object(); // {}로 빈 객체를 생성하는 것과 같은 효과

/**
 * ? Object 생성자 함수는 new 키워드를 통해 객체를 생성하고 초기화하는 함수다. 
 * ? 생성자 함수는 변수 타입 변환에서도 사용했던 빌트인 메서드 String,Number,Boolean,Array 등등도 생성자 함수이다.
 * ? 일반 함수와 생성자 함수의 구분을 위해 파스칼 케이스 문법을 사용해 식별자를 설정하고, 
 * ? 중간 중간 대문자를 넣는 문법이다. -> PascalCase 
 */

/** 
 * ! 두 개의 생성 방법의 차이
 * ! 객체 리터럴인 {}로 인해 생셩된 객체는 new Object()의 축약 표현일 뿐이다.
 * ! 그러기 때문에 둘은 같은 문법이며, 간단하게 {} 를 사용하는 게 훨씬 이득이다.
*/

/**
 * * 생성자 함수
 * ? 객체 자체를 생성하는 위 두 가지 방법은 같은 사물을 표현할 땐, 객체를 생성하면서 계속 같은 프로퍼티 값을 넣어야
 * ? 하는 불편함이 있다. 자바는 이를 해결하기 위해 생성자를 통해서 이를 해결했으며,
 * ? 자바스크립트 또한 자바와 같은 생성자 패턴을 사용할 수 있다. 물론 디자인만 저렇게 되있는거다.
 */


function Dungeon(name,floor,level) { // 함수이기 때문에 객체의 프로퍼티 설정 방법과 다르다. 
    this.name = name; 
    this.floor = floor;
    this.level = level; 
    
    this.welcome = function() {
        console.log(`Welcome! My beautiful Dungeon\n`+`Name : ${this.name}\n`+`Floor : ${this.floor}\n`+`Level : ${this.level}`);
    }
}

var castle = new Dungeon("castle",10,"Hard"); // new를 통해 객체 생성 -> 자바와 비슷함

castle.welcome(); // 함수 프로퍼티 사용


/** 
 * ? this 키워드는 객체 내에서 자기 자신을 가리키는 역할을 하고 있다. 말로 하면 어려우니 예를 들어보자.
 * 
 * TODO function Voice(say) {
 * TODO     say = say; 
 * TODO }
 * ! 위에 코드의 할당문에서 객체 자체의 say 와 매개변수인 say의 구분이 쉽지 않음을 알 수 있다.
 * ! 이런 코드들이 많아 진다면 가독성은 최악을 달릴거고, 인수인계가 일어날 경우 대참사가 일어난다.
 * ! 그러기에 객체 내의 프로퍼티 라는 점을 확실하게 하기 위해, this를 통해 자신의 프로퍼티를 강조시킨다.
 * */

/**
 * * this 키워드의 특징
 * ? 1. 생성자 함수를 생성할 땐 대문자로 시작하는 것이 좋다.
 * ? 2. this에 연결(바인딩)되어 있는 프로퍼티와 메소드는 외부에서 참조가 가능해 진다. 자바로 따지면 public이 된다.
 * ? 3. 자바의 캡슐화를 위한 private 화는 this를 사용하지 않은 생성자 함수 내부 변수로 구현했다.
 * ? 즉, 외부에선 참조할 수 없다. 
 */

/**
 * ! 생성자 함수의 주의사항 
 * ! 클래스 기반 객체지향 언어는 클래스를 정의하는 형식이 정해져 있기 때문에 순수하게 클래스만을 정의하기 위한 용도로만 쓰이지만,
 * ! 자바스크립트는 함수를 통해 클래스 구현을 지원하므로 일반적인 함수로도 쓰일 수 있다. 그렇기 때문에 첫 대문자를 사용해
 * ! 이 함수는 객체 생성자라는 점을 구분해야 한다. 가독성은 올리도록 하자.
 */

/** 
 * * 프로퍼티 키 설정 규칙
 * ? 프로퍼티 키는 객체 내의 데이터를 참조하기 위한 식별자다. 
 * ? 자바스크립트는 일반적으로 문자열과 symbol 값을 식별자로 사용할 수 있게 다른 타입으로 설정할 경우 강제 타입 변환으로
 * ? 문자열 값으로 바뀐다. 헷갈리지 않게 문자열이나 symbol만 사용하자. 
 * ? 그 외에 자바스크립트 내에서 유효한 식별자는 프로퍼티 키로 ""을 사용하지 않아도 된다.
 * ? 위에 프로퍼티 키 모두 ""을 사용하지 않았으며 유효하지 않을 경우에만 ""을 사용하도록 한다.
 * ? ex) +string -> +연산자는 식별자로 사용할 수 없는 연산자 이므로 ""을 사용해 강제 변환
 * ! 왠만하면 쓰지말자. 보기 힘들 거 같다.
 * ! 예약어를 프로퍼티 키로 사용하지 말자.
*/

/** 
 * * 프로퍼티 값 접근
 * ? 접근 연산자인 . 연산자를 통해 객체의 프로퍼티의 접근할 수 있다.
*/

console.log(castle.name); // 접근 연산자 .를 통해 객체의 프로퍼티의 접근

/** 
 * ! 예외 
 * ? 유효하지 않은 값으로 프로퍼티 키를 만들었다면, . 연산자로 접근할 수 없다.
 * 
 * TODO Harf-Life 라는 프로퍼티 키를 설정했다. 이럴 경우에는
 * TODO castle.Harf-life 를 사용할 경우 . 연산자 다음 -를 빼기 연산자로 인식하기 때문에
 * TODO 오류가 난다. 
 * 
 * ? 그러기에 사용하는 대체 접근 연산자가 []이다. 
 * ? 유효하지 않은 프로퍼티 키는 []을 통해 접근할 수 있고, 반드시 문자열로만 이루어져야 한다.
 * ? castle['Harf-life'] 이렇게.
*/

/**
 * * 프로퍼티 값 갱신
 * ? 할당 연산자를 사용하도록 하자.
 */

castle.name = "Tower";

console.log(castle.name); // 변경 완료.


/** 
 * * 프로퍼티 접근과 생성의 차이
 * ? 존재하지 않는 프로퍼티 값에 접근하면 undefined를 반환하지만,
 * ? 존재하지 않는 프로퍼티 값에 값을 할당하면 동적으로 키를 생성하고 값을 할당한다.
*/

console.log(castle.weapon); // undefined

castle.weapon = "Wooden Sword";
console.log(castle.weapon); // 프로퍼티 키를 생성하고 값을 할당 -> 동적 할당

/** 
 * * 프로퍼티 삭제
 * ? delete 를 사용해 삭제할 수 있다.
*/

delete castle.weapon; // 삭제 완료

console.log(castle.weapon);

/** 
 * * for-in 문 
 * ? 객체의 모든 프로퍼티를 순회하는 반복문을 사용하기 위해 만들어졌다.
 * ? 배열도 사용가능하며, for-in 문의 단점은 프로퍼티나 배열의 구분 없이 모든 키와 값을 순회한다는 것.
 * ? 그리고 순서가 보장되지 않는다. 원래 프로퍼티는 순서가 없다.
*/

for (var cycle in castle) { // cycle 변수에 프로퍼티 키 가 반환된다.

    if(cycle === "welcome") { // 함수는 너무 길어서 뺐다. 
        continue;
    }

    console.log(`${cycle} : ${castle[cycle]}`);
}

/** 
 * * for-of 문
 * ? 순수하게 배열 요소만을 순회하기 위해선 for-in이 아닌 for-of 를 쓰면되고,
 * ? 문법은 in을 of로만 바꾸면 된다. 
 * ! 자바스크립트 배열에는 모든 값을 자유롭게 넣을 수 있다. 심지어 객체마저도.
 * ! 하지만 for-of 문은 배열 요소만을 순회하고, 객체는 제외한다.
*/



/** 
 * ! pass-by-reference , pass-by-value 
 * ? 참조값을 전달하냐 원시값을 전달하냐의 차이. 
*/


/** 
 * * 원시값에 의한 전달 (pass-by-value)
 * ? 변수 부분에서 설명했듯이 자바스크립트 원시값은 불변성을 갖고있다. 
 * ? 그러기에 다른 변수에 값을 넘길때는 값을 "복사"해서 전달한다. 예를 보자
*/

var one = 5; 

var two = one; 

/** 
 * ? one 이라는 변수에 5라는 원시값을 할당했고, two에는 one 변수에 들어있는 5라는 값을
 * ? 넘겨주었다. 값을 "복사"해서 넣는다는 의미는 값이 저장된 메모리 참조값을 넘기는 게 아닌,
 * ? 순수하게 리터럴 값만을 넘기겠다는 의미다. 5 가 저장된 메모리 주소를 공유하는 게 아닌
 * ? 5라는 값만을 넘기는 것이다. 
*/

var two = 6;

console.log(one); // 5 가 출력된다.

/** 
 * ? 고정 원시값을 가지기 때문에 메모리 또한 고정값으로 차지하고, 그러기 때문에 변수 할당 시점(런타임)
 * ? 에는 메모리 스택에 고정된 메모리 영역을 차지한다.
*/


/** 
 * * 참조값에 의한 전달 (pass-by-reference)
 * ? 원시값을 제외한 객체,배열등등이 참조값을 넘기는 매커니즘을 갖고있다.
 * ? 원시값이 불변성을 갖지만, 객체는 프로퍼티 요소와 값을 변경할 수 있기 때문에
 * ? 값을 "복사"해서 넘길 필요 없이 메모리를 효율적으로 활용하기 위해 메모리 영역을 참조할 수 있는
 * ? 접근 권한인 참조값을 넘긴다. 즉, 주소를 넘긴다.
*/

var refer = {
    profer : 1,
    string : "hello"
}

var ence = refer; // 주소값을 "공유"하게 된다. 같이 쓰는거다.

ence.profer = 4;

console.log(refer); // refer 프로퍼티가 바뀌었다. 둘은 공유재산임을 알 수 있다.

/** 
 * ? 객체 값은 유동적으로 계속 변할 수 있기 때문에 메모리 영역 또한 
 * ? 고정되지 않고 메모리의 힙(Heap) 영역에 저장된다.
 * ? 원시값은 스택 참조값은 힙이다. ㅇㅋ?
*/