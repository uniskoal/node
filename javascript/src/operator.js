/** 
 * * 표현식 
*/

/** 
 * ? 프로그래밍 언어에선 표현식은 단순히 값을 만드는 방법이다.
 * ? 표현식은 리터럴,식별자,연산자,함수 호출 등의 조합으로 할당,연산 같은
 * ? 동작을 통해 하나의 값을 만드는것이다. 말이 복잡해도 표현식으로 
 * ? 하나의 값을 만든다고 생각하면 된다.
*/

10; // 단순히 리터럴 값 10을 만든다. 

10 + 20; // +연산자를 통해 30 이라는 값을 만들었다.

var sum = 10;

sum; // sum이라는 변수를 선언하고 (표현식 x -> 선언을 했을뿐 값이 생기지 않았다.) 10을 할당했다. (표현식 o > 변수에 10이라는 값을 만들어 할당.)

function add(a,b) {
    return a+b;
}

add(1,2); // 변수나 함수 선언은 표현식이 아닌 "문"이다. 함수를 호출해 값을 return으로 반환받으면 값을 만들었기에 표현식

/** 
 * ? 표현식은 값을 만드는 방법으로써, 하나의 값이 되기 때문에 값과 동등한 관계를 가진다.
 * ? 따라서 값처럼 사용할 수도 있다. 
*/

var avg = y = 10; // y = 10은 할당"문"이자 표현식이다. 표현식은 값처럼 사용할 수 있으므로 값의 위치에 사용할 수 있다.  

/** 
 * * 문 
 * ? 표현식은 하나의 값을 만드는 방법이라면, 문은 자바스크립트 엔진에게 이 일을 하라고 명령을 내리는 것이다.
 * ? 그냥 평범하게 코드를 작성하고 ;로 문장의 끝을 알린다면, 그건 하나의 문이 된다. 컴퓨터에게 명령을 내렸으므로
 * ? 표현식은 명령을 내려 하나의 값을 만들기 때문에 표현식이면 반드시 문이 될 수 있다. 문은 반드시 표현식인 것은 아니다.
 * ? 값을 만들지 않고 함수를 선언하거나 변수를 선언하는등 값을 만드는 것 외에도 자바스크립트가 할 일은 많기 때문이다.
 * */

/** 
 * ! 표현식이 아닌 문
*/

var dec; // 식별자를 선언했다. 실제로 값이 저장되지 않지만 자바스크립트가 undefined 를 할당해 놓는다.

function too() {} // 함수를 선언했다. 

if (dec === undefined) {} // 조건문을 설정했다.

// 간단한 조건의 경우 삼항 연산자로 조건문을 표현식으로 표현할 수 있다.

var truth = dec === undefined ? true : false; // true란 값을 조건에 따라 만들었다.

console.log(truth);

for (var i = 0; i < 10; i++) {} // 반복문을 설정했다.


/** 
 * * 연산자
 * ? 하나 이상의 표현식을 대상으로 산술,할당,비교,논리,타입 계산을 수행할 수 있는
 * ? 연산자를 통해 하나의 값을 만든다. 연산의 대상을 피연산자라고 한다. 
 * ? 참고로 연산자도 값을 만들어 내는 주체기 때문에 표현식이다. -> + * / 
*/

/** 
 * ! 산술 연산자
*/


/** 
 * * 이항 산술 연산자 
 * ? 연산의 대상인 피연산자 하나를 일항으로 본다. 
 * ? 이항은 두개의 피연산자를 사용해 값을 만드는 걸 뜻한다.
*/

2 + 4; // 4개는 사칙연산의 기본. 몰라선 안 된다.
2 - 4; 
2 * 4; 
2 / 4; 
2 % 4; // 나누기의 나머지를 구하는 연산자 

/** 
 * * 단항 산술 연산자
 * ? 단항은 위에서 설명한 것처럼 한 개의 항을 사용한다.
 * ? 단항 연산자로는 전위,후위 증감 연산자가 있다.
*/

var fruit = sum++; // sum의 값은 위에 할당된 10. 전위  10

var apple = ++sum; // 후위 12 

console.log(fruit,apple);

/** 
 * ? ++은 단항 증가 연산자로써, 피연산자의 값을 1 증가시켜주는 연산자다.
 * ? ++이 피연산자 왼쪽에 있으면 전위, 오른쪽에 있으면 후위다.
 * ? 전위는 값을 할당하는등 연산을 하기 전에 증가하고, 후위는 연산을 한 뒤 증가한다.
 * ? --도 똑같이 작용한다.
*/

console.log(+'10');

console.log(-(-10));

/** 
 * ? 수학에서 배우는 단순한 + , -는 양수는 양수 그대로
 * ? 음수는 반대로 바뀌는 성질을 갖고 있다.
 * ? 자바스크립트는 이 연산자를 사용할 시 숫자 타입이 아닌 리터럴은 숫자
 * ? 타입으로 타입 강제 변환이 된다.
*/


/** 
 * * 문자열 연결 연산자
*/

10 + '10' // 20 

10 + true // 11

10 + false // 10

console.log('10' + true);

1 + null // null -> 0

1 + undefined // undefined -> NaN

/** 
 * ? 더하기 연산을 하는 + 는 문자열을 연결할 때도 사용한다.
 * ? 타입 강제 변환으로 인해 피연산자중 문자열이 있을 경우, 숫자 타입은 문자열이 된다.
 * ? true는 1, false는 0이 된다. 
 * ? 문자열과 boolean은 boolean도 문자열이 된다.
*/

/** 
 * * 할당 연산자
*/

sum = 20;  // 20이라는 값을 할당했다.

sum = sum + 20; // 자기자신을 피연산자로 사용해 할당할 경우, 간단하게 줄일 수 있다.

sum += 20; // 위의 식이랑 똑같다. 계산 연산자는 다 똑같이 사용할 수 있다.


/** 
 * * 동등/일치 연산자
*/

10 == '10' // true

10 === '10' // false

10 == 20 // false

/** 
 * ? == 연산자는 좌항과 우항의 타입을 일치시킨 후 리터럴 자체를 비교한다. 
 * ? 따라서 숫자 타입과 문자열 타입 일지라도 값이 같으면 true를 반환한다.
 * ? 허나 === 연산은 타입을 일치시키지 않고 값과 타입이 모두 같아야 true를 반환한다.
 * ? ==는 여러모로 이상한 값을 도출시킬 수 있기 때문에 왠만하면 ===을 쓰자.
*/

0 == '0' // true
0 == '' // true
'' == '0' // false ????????
false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true ??????????????????

/** 
 * ! 부등 비교 연산자
 * ? == 의 반대격인 != 은 값이 같으면 false !== 는 타입과 값이 같으면 false를 반환한다. 완전히 반대
*/

NaN === NaN // false 

/** 
 * ? 값 자체가 유일하고 고유한 값인 NaN은 동등 연산자로 true를 반환할 수 없다.
 * ? 대신 isNaN 함수가 있다.
*/

isNaN(NaN); // true

/** 
 * * 대소 관계 비교 연산자
 * ? 수학에서 사용하는 <,>,<=,>= 이다. 딱히 설명할 건 없다.
*/

/** 
 * * 삼항 조건 연산자
 * ?  피연산자 3항을 통한 연산은 위에 표현식 설명에 나와있는 조건 연산자다.
*/

/** 
 * * 논리 연산자
 * ? 논리 연산은 좌항과 우항을 비교해 논리값 boolean 을 연산.
*/

// 논리합(||) 연산자
true || true   // true
true || false  // true
false || true  // true
false || false // false

// 논리곱(&&) 연산자
true && true   // true
true && false  // false
false && true  // false
false && false // false

// 논리 부정(!) 연산자
!true  // false
!false // true

/** 
 * * typeof 연산자
 * ? 이름의 뜻을 해석해 ?의 type을 알려주는 연산자로써, 대상이 되는
 * ? 피연산자의 데이터 타입을 문자열로 반환한다. 
*/

typeof 'apple' // string
typeof 1 // number
typeof NaN // number
typeof true // boolean
typeof undefined // undefined -> 선언 돼있지 않은 변수도 undefined 를 반환
typeof Symbol() // symbol

typeof null // object
/** 
 * ! object로 반환되는 것은 자바스크립트 과거형 설계로써, 원래는 null이 맞지만
 * ! 잘못 반환되고 있다.
*/

null === null // 이걸로 확인할 수 있다.


