
/**
 * * 함수 
 * ? 특정한 목적을 가지고 실행되는 문들의 모음. 
 * ? 매개변수와 코드 블록으로 이루어져 있으며, 필요한 때에 어디서든 호출할 수 있다.
 */

function hello() {
    console.log("Hello World!");
}

hello();

/**
 * * 함수의 장점
 * ? 어디서든지 쉽게 호출할 수 있고, 특정한 기능을 사용할 때마다 일일이 코딩할 필요 없이
 * ? 미리 정의해 자유롭게 꺼내다 쓸 수 있기 때문에, 재사용성 증가에 효과가 있다.
 */

/** 
 * * 함수의 활용
 * ? 자바스크립트에서 함수는 일급 객체로 취급되므로, 값으로써 사용될 수 있다.
 * ? 변수에 인자로 넘길 수도 있고 매개변수로 사용할 수도 있으며, 값을 저장할 수 있는 곳에는
 * ? 함수도 저장할 수 있다. 객체를 효율적으로 생성하는 생성자 함수 또한 "함수"다.
*/

/** 
 * * 함수를 정의하는 방식
 * ? 함수를 정의하는 방식은 3가지가 있다.
 * ! 함수 선언문
 * ! 함수 표현식
 * ! Function 생성자 함수
*/

/** 
 * ! 함수 선언문
 * ? 변수를 선언하듯이 function 함수를 선언하고 정의하는 방식. 정의에는 규칙이 있다.
 * ? 함수명은 절대로 생략할 수 없다.
 * ? 자바스크립트 디버거가 해당 함수를 식별할 수 있는 식별자 사용
 * ? 매개변수가 없더라도 ()를 사용해야 한다.
 * ? 결과값을 반환할 땐 return을 사용.
*/

function Warrior(weapon,hp) {
    this.weapon = weapon;
    this.hp = hp;
    this.equipment = {
        weapon : this.weapon,
        armor : 'cloth armor',
        accessories : {
            equip1 : 'ring',
            equip2 : 'necklace',
        }
    };
    this.character = () => { // ? 매개변수가 없을시 익명함수를 사용할 수 있다.
        console.log(this); // 자신의 정보를 호출 
    }
    this.weaponchange = () => {
        this.equipment.weapon = this.weapon;
    }  
    
}

const player = new Warrior('Wooden Sword','hp');

player.weapon = 'Sword';

player.weaponchange();

player.character();




function objtype(obj) { // ? obj 라는 매개변수를 이용해 특정한 기능을 수행 다른 언어와 달리 타입을 미리 정하지 않는다.
    const objProps = Object.getOwnPropertyNames(obj);

    objProps.forEach((name) => {
        console.log(name + ":" + typeof obj[name]);
    });
}

objtype(player);

/** 
 * ! 함수 표현식
 * ? 표현식은 하나의 값을 만드는 것이다, 일급 객체인 함수는 값으로써 사용될 수 있고,
 * ? 하나의 값을 만드는 표현식에서 또한 사용할 수 있다.
*/

var npc = function() {
    return console.log('Hello Warrior!');
}

/** 
 * ? 할당 또한 표현식이기 때문에 유효하다.
*/

npc();

/** 
 * ! 함수 표현식으로 정의한 함수는 함수명을 생략할 수 있습니다.
 * ! 생략하지 않아도 함수 이름이 아닌 변수 식별자를 통해 함수를 불러올 수 있습니다.
 * ! 익명함수는 또한 간단하게 표현할 수 있다. 일단 알고만 있자.
*/

var shop = () => {
    console.log('welcome');
}

shop();

/** 
 * ? 함수 선언문도 사실은 함수 표현식처럼 객체 리터럴 방식으로 정의된다.
 * ? 단순함을 추구하기 위해서 단축 시킨 듯 하다.
*/


/** 
 * ! Function 생성자 함수
 * ? 함수 선언문,함수 표현식은 자바스크립트 내장 함수인
 * ? Function 생성자 함수로 생성하는 것을 단순화한 축약식이다.
 * ? 그래서 이게 원본이나 축약시킨 이유가 괜히 있는 것이 아니니 사용하지 않는 걸 추천한다.
*/

var func = new Function('num1','num2','return console.log(num1+num2)');

func(1,2);

/** 
 * ! 사용을 자제하자 축약식이 두 개나 있다.
*/

/** 
 * * 함수 호이스팅
 * ? 변수 편에서 알아봤듯이 호이스팅은 모든 선언문의 스코프가 맨 선두로 올라가듯이
 * ? 작동하기 때문에 선언되기 이전에도 참조할 수 있는 특성을 말한다.
 * ? 그런데 함수를 어떻게 정의하냐에 따라 이 호이스팅에 동작 방식에 대한 차이점이 있다.
*/

hoisting("hello");

function hoisting(text) {
    return String.prototype.toUpperCase(text);
}

/** 
 * ? 함수 선언문의 경우 자바스크립트 엔진이 스크립트가 로딩되는 시점에
 * ? 함수 선언,초기화,할당이 한번에 이루어진다. 
 * ? 이루어 질 때는 VO(variable object)에 저장한다.
 * ? 한 번에 이루어진다는 건 선언 전에 호출을 해도, 그 과정이 한 번에 이루어졌기에
 * ? 위치와는 상관없이 호출이 가능하다.
*/

// ? var hoist = hosit(); // TypeError 발생

var hosit = function() {
    return 5;
}

/** 
 * ! 함수 표현식의 경우에는 변수에 값을 할당하는 것이기 때문에
 * ! 엄연히 변수 호이스팅이 발생한다. 
 * ! 호이스팅된 변수는 할당이 아닌 변수 등록과 초기화까지만 한번에  진행되므로
 * ! 참조할 때 undefined를 반환한다. 그러므로 선언이 안 된 객체를 넣었으니 TypeError가 날 수 밖에 없다.
*/

/** 
 * ? 함수 표현식은 변수 호이스팅으로 작동하기 때문에 VO에 저장되지 않고 
 * ? 자바스크립트 런타임에 의해서 변수 등록과 초기화만 이루어진다.
*/

/** 
 * * 함수 호이스팅의 단점
 * ? 함수 호이스팅은 함수의 규칙인 호출 전 반드시 선언되어야 한다는 규칙을 깨버린다.
 * ? 게다가 vo라는 객체에 저장된다는 의미는 메모리를 잡아먹는다는 뜻이므로,
 * ? 너무 남용되면 응답속도가 떨어질 수 있다.
 * TODO 함수 표현식 짱짱 권장
*/

/** 
 * * 일급 객체
 * ? 일급 객체가 되기 위한 조건은 4가지가 있다.
 * ? 무명의 리터럴로 표현이 가능하다.
 * ? 변수나 자료 구조(배열,객체)에 저장할 수 있다.
 * ? 함수의 매개변수에 전달할 수 있다.
 * ? 반환값으로 사용할 수 있다.
*/

/** 
 * TODO 1. 무명의 리터럴로 표현이 가능하다.
 * ? 자바스크립트 에는 함수 선언문을 제외한 표현식,값처럼 사용할 때
 * ? 익명함수로 사용할 수 있다. 함수 식별자를 정의할 필요가 없을 때 사용한다.
*/

var set = () => {
    return "name";
}

var set = function() {
    return "name";
} // 같은 변수명 사용시 재할당이 이루어진다.

// ? 익명함수일 경우 축약식으로 간단하게 표현 가능하고 두 개의 문을 똑같다.

/** 
 * TODO 2.변수나 자료구조(배열,객체)에 저장할 수 있다. 
 * ? 대표적으로 함수 표현식이 있고, 객체 내에서도 함수를 정의할 수 있고,
 * ? 대표적인 자료구조인 배열에도 언제든지 값처럼 사용할 수 있다.
*/

var arr = [];

arr = function name() {
    console.log("array");
}

console.log(arr);

/**
 * TODO 3.함수의 매개변수에 전달할 수 있다.
 * ? 값처럼 사용되는 일급 객체는 역시 매개변수로 사용할 수 있다.
 */


/** 
  * * 매개변수 (함수 인자)
  * ? 함수를 정의할 때 외부 데이터를 받아와 연산을 실행해야 하는 경우에 사용한다.
  * ? 함수 내에서 변수의 역할을 한다. 
 */

/** 
 * * 함수 인자
 * ? 실제 함수를 호출할 때 매개변수의 정의된 수만큼 인수를 할당하는데,
 * ? 함수 정의에 따라 인수를 넣지 않아도 에러는 나지 않는다. 적게 되면 나머지는 undefined 많게 되면 나머지는 무시당한다.
*/

/** 
 * ! 순수 함수 vs 비순수 함수
 * ? 함수문을 실행했을 때, 외부 변수나 객체를 변경하는 함수를 순수 함수,
 * ? 그렇지 않은 함수를 비순수 함수라고 한다. 예를 들어보자.
*/

var pure = "pure";

var impure = {
    nickname : 'impure',
    opposition : 'pure',
}

function change(one,two) {
    one += pure;
    impure.nickname = two;
}

change("hi","eva");

console.log(pure,impure);

/** 
 * ! 함수로 인해 impure 객체의 프로퍼티 값이 변경됐다. 객체는 불변성을 지니지 않고 참조값을 전달하기에 
 * ! 변경할 수 있다. 이렇게 내부 함수에 의해서 외부 값이 변경되는 걸 비순수 함수라고 한다.
 * ! pure값은 원시값이기에 복사값만을 넘기고 참조값은 넘기지 않아서 영향이 없다. 
*/

/** 
 * * 반환값 (return)
 * ? 함수는 특정한 기능을 실행하는 문들의 모임으로써, 값을 연산하거나 외부 변수의 값을 변경하는 비순수 함수로써
 * ? 기능할 수도 있고, 굉장히 복잡한 기능을 실행하기도 하지만, 값을 반환하는 경우도 있고 하지 않는 경우도 있다.
 * ? 이 때 값을 반환하기 위해 사용하는 키워드가 return 이다. 
 * ? reutrn 값은 하나가 아닐 수도 있따. 객체 일 수 있으며, 함수일 수도 있고, 배열일 수도 있다.
 * ! return 을 사용하면 해당 값을 반환하고 함수를 종료한다. return 뒤에 뭘 쓰지 말자. 실행 안 된다.
*/



// 기본 빌트인 객체중 getOwnPropertyNames -> 객체의 프로퍼티 키를 배열로 전환. 
// 을 한 번 구현해봐야지.

const getPropertyNames = (obj) => {
    const props = [];

    for (var keys in obj) {
        props.push(keys);
    }

    return props;
}

var data = getPropertyNames(player); // 구현 완료. 

console.log(data); // 잘 작동한다. 

/** 
 * ? 자바스크립트 자체 내장 객체인 Object의 내부 메서드인 getOwnPropertyNames() 을 흉내내 봤다.
 * ? 위의 함수는 객체의 프로퍼티 값을 배열 형태로 반환하는 역할을 한다. 이 때 return을 사용해서 값을 반환한 걸 알 수 있다.
*/

/** 
 * * 함수 객체의 프로퍼티
 * ? 함수도 객체이므로 프로퍼티 값을 가질 수 있다.
 * ? 굳이 함수에 프로퍼티를 붙이는 건 권장되지 않고, 함수는 자기만의 프로퍼티 값을 따로 갖고 있다.
 * ? 보이지 않지만 내부적으로 가지고 있다. 
*/

/** 
 * * argumennts (함수 인자) 
 * ? 호출할 때 받아온 외부 인자를 유사 배열 객체의 형태로 담고있는 내부 객체
 * ? 외부에서는 이 내부 객체를 사용할 수 없다. 
 * ? 함수 내부에서 지역 변수처럼 자유롭게 사용할 수 있다. 
 * TODO arguments 객체는 매개변수 수가 정해지지 않는 가변 인자 함수를 구현할때 굉장히 유용하다.
*/

function sum() {
    var plus = 0; 

    for(var i = 0; i < arguments.length; i++) {
        plus += arguments[i];
    }

    return plus;
}

console.log(sum(1,3,4,7,9,9,6,4,5,2,3,7,4));

/** 
 * ? 단순히 인자값을 모두 더하는 함수라도, 그 인자가 굉장히 많아지면,
 * ? 미리 정의하기 쉽지 않다. 그럴 때 내부 유사 배열 객체를 사용한다면,
 * ? 모든 인자를 쉽게 참조할 수 있는 arguments를 통해 모든 값을 
 * ? 수월하게 연산할 수 있다.
 * 
 * ! 함수 표현식으로 선언될 경우 arguments가 이상한 값을 반환한다.
 * ! 아직 뭔지 모르겠다. 객체를 반환하고 있다.
 * ! 유사 배열 객체인 arguments는 length프로퍼티 값을 가지고있고, 배열처럼 참조할 순 있으나,
 * ! 배열 메소드는 사용할 수 없다. 사용하기 위해선 개별 메서드를 사용해야 한다.
*/

/** 
 * * caller 프로퍼티
 * ? 자신의 함수를 호출한 함수가 무엇인지 반환한다.
*/

function call(func) {
    return func();
}

function bar(args) {
    return 'caller : ' + bar.caller;
}

console.log(call(bar));

/** 
 * ! 함수를 인자로 넘길 경우에는 ()를 빼고 넣자.
 * ! 이 부분은 계속 봐야겠다.
*/

/** 
 * * length 프로퍼티
 * ? 함수를 정의할 때 작성된 매개변수 갯수를 나타낸다.
 * ? 호출 시 인자가 아닌 정의할 때의 갯수다. 조심하자.
*/

/** 
 * * name 프로퍼티
 * ? 자신의 함수 이름을 반환하고, 익명함수일 경우 빈 문자열을 값으로 가진다.
*/

/** 
 * * __proto__ 접근자 프로퍼티
 * ? 자바스크립트 모든 객체는 [Prototype]이라는 내부 슬롯이 있다.
 * ? [Prototype] 내부 슬롯은 프로토타입 객체를 가리킨다.
 * ? 자바스크립트 객체는 클래스가 아닌 프로토타입 기반 상속 언어로써, 프로토타입 객체는
 * ? 다른 객체에 공유 프로퍼터를 제공하는 객체입니다. 쉽게 말하면 객체간의 상속을 구현하기 위해 사용됩니다.
 * ? 자바스크립트는 클래스도 지원하지만 디자인만 구현해 놓은 것이기에, 기본은 프로토타입입니다.
*/

/** 
 * ? __proto__ 프로퍼티는 프로토타입 객체에 직접적으로 접근할 순 없고,
 * ? 간접적으로 접근할 때 사용된다. 
*/

console.log({}.__proto__ == Object.prototype);

/** 
 * * __proto__ 접근자는 객체가 직접 소유하는 프로퍼티가 아닌 Object라는 ECMAScript 에서 명세한
 * * 자바스크립트 내장 객체의 프로퍼티다. 
 * * 자바스크립트로 만들어지는 모든 객체는 Object라는 최상위 부모 요소를 가지고 있으며,
 * * __proto__ 프로터티 또한 상속 받은 것이다.
*/

/** 
 * * 함수 또한 객체이므로 접근할 수 있고 이때 부모 프로퍼티는 Function.prototype 이다.
*/

console.log((function() {}).__proto__ == Function.prototype);

/** 
 * * prototype 프로퍼티
 * ? __proto__ 프로퍼티 와는 다르게 객체 리터럴로 생성되는 것이 아닌
 * ? 생성자 함수로 인해 생성된 인스턴스 객체의 prototype 객체를 간접 접근할 수 있다.
 * ? 일반 객체는 prototype 프로퍼티가 없고 또 다른 점은 함수 객체가 직접 소유하는 프로퍼티다.
*/

console.log(Warrior.prototype); // ???????


/** 
 * * 함수의 다양한 형태
 * ? 함수가 사용되는 용도에 따라 다양한 형태로 사용할 수 있다.
*/

/** 
 * * 즉시 실행 함수(IIFE)
 * ? 말 그대로 따로 호출식 없이 정의되는 순간 바로 실행되는 "즉시" 실행 함수이다.
 * ? 이 함수의 활용처는 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다.
*/

(function () {

})();

/** 
 * ? 이름이 있는 함수를 호출할 때랑 똑같이 호출하되,
 * ? 이름 부분에 직접 함수를 정의하면 된다.
 * ! ()로 이름 부분을 감싼 이유는 함수 몸체를 닫는 중괄호 뒤에 자바스크립트 엔진이
 * ! 자동으로 ;을 넣어 끝내버리기 때문 그래서 함수는 ;를 사용하지 않는다. 
 * ? 익명함수일 경우 단축식을 통해 더 줄일 수 있다.
*/

(() => {
    console.log("IIFE");
})();

/** 
 * ! 자바스크립트 함수의 엄청난 문제점
 * ? 자바스크립트는 값의 유효 범위를 나타내는 스코프를 
 * ? 글로벌 스코프로 단 하나를 갖고 있다. 글로벌 스코프는 쉽게 말하면 전역 변수인데
 * ? 글로벌 스코프가 하나이기 때문에 다른 스크립트 파일 내에서 또한 중복 변수와 함수 문제가
 * ? 일어날 수 있다. 정말 엄청나다. 
 * ? 이를 막기 위해 외부에서 절대 접근할 수 없는 IIFE 를 통해 중복 충돌을 방지할 수 있다.
*/

/** 
 * * 내부 함수
 * ? 함수 내에서 정의된 함수를 내부 함수라고 한다. 
 * ? 내부 함수에서 정의된 변수는 이러한 규칙을 갖고 있다.
 * TODO 1. 부모 함수의 데이터에 접근할 수 있다.
 * TODO 2. 부모 함수는 자식 함수의 데이터에 접근할 수 없다.
 * TODO 3. 외부에서 내부 함수 데이터에 접근할 수 없다.
*/

/** 
 * * 재귀 함수
 * ? 자기 자신을 호출하는 함수를 말합니다.
 * ? 재귀 함수에 대한 이해도가 부족해 완벽히 이해하면 추가
*/


/**
 * * 콜백 함수
 * ? 이 부분은 node.js 공부할 때 따로 쓰도록 할게용.
 */