
/** 
 * * 타입 변환
 * ? 모든 데이터는 효율적인 메모리 관리를 위해 데이터 타입을 가지고 있다.
 * ? 타입을 알기 위해선 일반적으로 typeof를 사용하고 null 같은 특수한 경우에는
 * ? === 연산자를 사용해 알아낼 수 있다. 
 * TODO 이 타입은 다른 타입간의 연산이나 직접 타입을 변환할 경우에 바뀔 수 있다.
 * ? 대표적으로 2가지 타입 변환이 있다.
*/

/** 
 * * 암묵적 타입 변환
 * * 타입 강제 변환
*/

var cas = 23; 

cas += ''; 

console.log(typeof cas); 

/**
 * ? 자바스크립트의 특징 중 하나는 데이터 타입을 사전에 정의하지 않고
 * ? 값을 할당 했을시 그에 따라 알맞은 타입을 할당하는 동적 타이핑 언어이다.
 * ? var 라는 변수에는 어떠한 데이터 타입도 들어갈 수 있기 때문에 다른 타입
 * ? 끼리의 연산이라도 자바스크립트 엔진이 암묵적으로 하나의 타입으로 변환하고 연산한다.
 * ? 위의 예시는 문자열 연결 연산자인 +를 통해 문자열이 하나라도 있으면 숫자 타입을
 * ? 강제로 문자열로 바꾼뒤 이어버린다.
 */


/** 
 * ! 변수의 불변성
 * ? 원시 타입의 변수는 일단 값이 할당되는 그 순간 그 리터럴은 절대 바뀔 수 없는 특징이 있다.
 * ? 따라서 자바스크립트 엔진에 의해 강제로 타입이 바뀌는 것도 원시값이 바뀌는 것이 아닌
 * ? 엔진이 임의로 그의 해당하는 타입의 값을 새롭게 만든 다음에, 그 값을 연산에 사용한 다음 버린다.
 * TODO 강제로 바뀐 타입의 값은 1회성이다. 자세하게는 참조할 수가 없기에 가비지 콜렉터가 메모리를 해제시킨다.
*/

/** 
 * ! 암묵적 타입 변환의 단점
 * ? 암묵이라는건 아무도 모르게 라는 뜻이다. 즉 개발자나 코드를 인수인계 받는 사람 입장에선 타입이 바뀌어버리는 것으로 인해
 * ? 문제가 발생할 수 있다. 위에 당장 cas += ''; 만 봐도 암묵적 타입 변환에 대한 이해가 부족하다면 저게 뭔지 알 수가 없다.
 * ? 따라서 자바스크립트 엔진이 데이터 타입을 어떨 때 어떤 식으로 바꾸는지 이해할 필요가 있다.
*/


/** 
 * * 문자열 타입 변환
*/

10 + '' // '10'
var age = `your age? : ${23}` // 'your age : 23'

/** 
 * ? + 연산자는 더하기 연산자 이기도 하지만, 템플릿 연산자가 없던 ES6 이전 시절, 문자열들을 서로 이어주던, 고마운 문자열 연결 연산자 이기도 하다.
 * ? 자바스크립트 엔진은 이 + 연산자를 문자열 연결 우선자로 보고 피연산자중 하나라도 문자열 타입이 있을 경우,
 * ? 다른 피연산자도 문자열 타입으로 강제변환된다.
 * TODO 단항 연산자 + 일 경우에는 숫자 타입으로 강제 변환된다. +'1' 일 경우.
*/

/** 
 * ? ES6 에서 새로 생긴 백틱(`)을 사용한 문자열 템플릿을 통해 문자열 안에 변수를 사용하거나,
 * ? 표현식을 사용할 수 있게 됐고, 여기서도 문자열로 자동으로 타입 변환된다. 
 * TODO 그 외에 다른 타입도 모조리 문자열 타입으로 변환된다.
*/

0 + ''              // "0"
-0 + ''             // "0"
1 + ''              // "1"
-1 + ''             // "-1"
NaN + ''            // "NaN"
Infinity + ''       // "Infinity"
-Infinity + ''      // "-Infinity"
// 불리언 타입
true + ''           // "true"
false + ''          // "false"
// null 타입
null + ''           // "null"
// undefined 타입
undefined + ''      // "undefined"



/** 
 * * 숫자 타입 변환
*/

1 - '1' // 1
1 * '20' // 20
1 / '2' // 0.5 



/** 
 * ? +연산자를 제외한 나머지는 산술만을 위한 연산자 이므로 피연산자는 반드시 숫자 타입이어야 한다.
 * ? 그러기 때문에 숫자 타입이 아닌 피연산자는 숫자타입으로 변환된다.
 * ? 그러나 숫자 타입으로 변환할 수 없는 객체,문자열은 NaN이 반환된다.
 * ! 맘대로 쓰지 말장
*/

'1' > 0  // true
console.log('str' > 0); // false 

/** 
 * ? 상대적인 크기를 통해 boolean 값을 정하는 비교연산자 또한 숫자 타입으로 변경된다.
 * ? 숫자 타입으로 변경할 수 없는 경우는 표현식 값 false를 반환한다.
*/

/** 
 * * 불리언 타입 변환
 * ? 주로 조건식에서 변환이 이루어진다. 조건식에는 단순히 비교문도 있지만
 * ? 다른 표현식도 사용할 수 있기 때문에, 이 식을 boolean 값으로 강제 변환 시켜야한다.
 * ? 이를 위해 자바스크립트 엔진은 Truthy 값(참 같은 값), Falsy 값(거짓 같은 값)
 * ? 으로 구분지어 변환시킨다.
*/

/** 
 * ! Falsy 값 (거짓 같은 값)
*/

// 이 값을 구별하기 위해 간단한 판단 함수를 만들 수 있다.

function realFalsy(discriminate) {
    return !discriminate;
}

console.log(realFalsy(false)); // true값이 나오는 게 정상이다. 매개변수가 false인지를 보는것이기 때문.
console.log(realFalsy(undefined));
console.log(realFalsy(""));
console.log(realFalsy(0));
console.log(realFalsy(null));
console.log(realFalsy(NaN));


/** 
 * ! Truthy 값 ( 참 같은 값)
*/

function realTruthy(discriminate) {
    return !!discriminate; // !는 부정연산자로써, 매개변수 값을 boolean 값으로 변환시킨다.
}

console.log(realTruthy(true));
console.log(realTruthy("ㅇ")); // 빈 문자열이 아닌 경우
console.log(realTruthy(1)); // 0을 제외한 정수(실수)
console.log(realTruthy([1,2,3])); // 배열, 객체 전부 참 같은 값



/** 
 * * 명시적 타입 변환
 * * 타입 캐스팅 
 * 
 * ? 사용자가 분명한 의지를 가지고 타입을 변환시키는 것을 명시적 타입 변환이라고
 * ? 합니다. 
 * 
 * ? 1. 래퍼 객체를 사용해 원시 타입을 임시 객채로 변환시킬 때
 * ? 2. 자바스크립트 자체 빌트인 메소드
*/


/** 
 * * 1. 래퍼 객체를 사용한 타입 변환
 * ? 래퍼란 일상생활에서 사용하는 비닐랲 처럼 내용물을 감싸는 의미를 지니고 있다.
 * ? 각 원시 타입에 해당하는 래퍼 객체를 사용해 임시적으로 객체로 변환시킨다.
 * ? 임시기 때문에 한 번 바뀐다음에는 그 값은 사라진다. 
*/

/** 
 * * 문자열 변환
*/

console.log(String(1)); // 객체 생성자인 new 를 사용하지 않고도 호출가능.
console.log(String(null));
console.log(String(undefined));
console.log(String(true));
console.log(String(false));
console.log(String([1,2,3])); 

/** 
 * * 숫자 변환
*/

console.log(Number("1"));
console.log(Number(true));
console.log(Number(false));
console.log(Number("sdsds")); // 문자열이 숫자가 아니다? NaN


/** 
 * * 논리 변환
*/

console.log(Boolean(1)); // true
console.log(Boolean(0)); // false

/** 
 * ? 위에 설명된 거짓,참 같은 값 전부 바꿀 수 있다.
*/

/** 
 * ! 임시 객체의 생명 주기
 * ? 임시 객체는 한 번 생성되고 바로 해제되는 특성이 있다.
 * ? 정확히는 객체의 프로퍼티를 참조하게 되면 값을 사용하고, 바로 삭제된다.
*/

var str = 'hello'; 

str.lab = 'clean';

console.log(str.lab); // undefined 


/** 
 * * 2. 자바스크립트 빌트인 메서드
 * ? 자바스크립트가 기본적으로 제공하는 빌트인 메서드등을 통해 타입 변환 
 * ? 여기서 빌트인이란 언어 설계 과정 (제작 과정) 에서 미리 만들어진 걸 뜻한다.
*/ 

/** 
 * * 문자열 변환
*/

var str = 100;
console.log(str.toString());

str = true;
console.log(str.toString());


/** 
 * * 숫자 변환
*/

console.log(parseInt('20')); // 문자열만 가능 

/** 
 * * 논리 변환
 * ? 위에서 설명했던 부정연산자 !를 사용하면 된다.
*/



