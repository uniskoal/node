
/** 
 * * 제어문 
 * ? 위 코드부터 차례대로 내려가면서 코드가 진행되는 것이 일반적인 흐름인데,
 * ? 이 흐름을 제어할 수 있는 문으로써, 조건문,반복문 등이 있다.
*/

/** 
 * * 블록문
 * ? 자바스크립트는 블록문을 하나의 단위로 취급한다.
 * ? 조건문,반복문에서도 이 블록문을 주로 사용하며, 단독으로는 잘 사용하지 않는 것 같다.
*/

var block = 3; 

{
    var block = 5;
}
console.log(block); // 5 

/** 
 * ? 변수 편에서 설명했듯이 var는 함수 레벨 스코프를 갖고 있다.
 * ? 함수 내에서 선언된 변수만을 외부에서 참조할 수 없는 굉장히 넓은 스코프를 가지고 있는데
 * ? 그 때문에 블록 안에서 선언된 변수도 밖에서 참조할 수 있게 된다.
 * ? 전역변수의 너무나도 넓은 범위로 문제가 발생할 수 있다. 그럴땐..?
*/

let black = 3;
{
    let black = 5;
}
console.log(black);

/** 
 * ? 변수는 동일한 식별자로 재할당을 할 수 있다. 위 코드를 보면 같은 식별자를 사용한 것처럼 보여도
 * ? 실제로는 다른 변수다. 블록 레벨 스코프를 가지는 let은 var와는 다르게 블록 내부 범위를
 * TODO 외부에서 참조할 수 없다. 즉 저 두 변수 할당문은 다른거다. 
 * TODO const 도 let과 똑같이 작동한다. const는 상수를 지정할 때 사용.
*/


/** 
 * * 조건문
*/

if(2 > 1) {
    // 이 문을 실행 
}

/** 
 * ? if는 만약이라는 뜻이고, ()안의 표현식의 boolean값을 연산 true일 경우, 블록문을 실행
 * ? false일 경우 실행하지 않는다. 말 그대로 조건에 따라 실행하겠다. 라는 뜻.
*/

if(1 < 2) {
    // 표현식이 false를 반환해 이 문은 실행되지 않음.
}
else {
    // else는 위 모든 조건식이 false 일 경우 실행.
}

/** 
 * ? else를 통해 조건식이 거짓일 경우 자동으로 else를 실행.
*/

if(1 < 2) {
    // 표현식이 false를 반환해 이 문은 실행되지 않음.
}
else if(2 > 1){
    // else는 위 모든 조건식이 false 일 경우 실행.
}
else {

}

/** 
 * ? 조건은 하나가 아닌 여러개일수 있다. 조건을 추가할 땐 else if (또한 만약에)
 * ? 로 조건을 추가한다.
 * TODO 조건문을 표현식 처럼 사용하기 위해선 삼항 조건 연산자를 사용한다. (변수 편에 설명)
*/


/** 
 * * switch 문 
 * ? 버튼을 의미하는 듯이, 조건을 평가하고 그 평가한 값에 맞는 버튼을 눌러 그 문을 실행하는
 * ? 구조를 갖고 있다. 
 * ? if와는 다르게 반드시 boolean값으로 평가되지 않는다. 그 표현식에서 반환된 값과 일치한 case(버튼)문을 실행한다.
*/

switch(2) {
    case 1 : 
        console.log(1);
    case 2 : 
        console.log(2);
    case 3 : 
        console.log(3);
    case 4 :
        console.log(4);
    default : // 모든 값을 찾지 못했을 때 실행
}

/**
 * ! switch에 들어간 값 2와 같은 값을 지닌 case 2 를 찾고 값을 출력했다.
 * ! 하지만 예상과 달리 아래 있는 3,4 문 까지 모두 실행해버렸다.
 * ! switch문은 값에 맞는 case를 실행한 뒤 그 아래 있는 문 까지 전부 
 * ! 실행해 버리는 특성을 갖고 있다. 따라서 모든 문에 break로 탈출할 수 있게 설계할
 * ! 수 있다.
 */

switch(2) {
    case 1 : 
        console.log(1);
        break;
    case 2 : 
        console.log(2);
        break;
    case 3 : 
        console.log(3);
        break;
    case 4 :
        console.log(4);
        break;
    default :
        break;
}

/** 
 * ? 무사히 2만 출력하고 나왔다.
*/

/** 
 * * 반복문
 * ? 조건식의 평가 결과가 참인 경우 해당 블록문을 실행시키며, 이 조건이 거짓이
 * ? 될 때가지 평가하고 문을 실행
 * ! 대표적인 반복문은 for,while,do while이 있고 
 * ! 그 다음 for.. in , for ... of 가 있다. 나중에 아라보자.
*/

/** 
 * * for 문 
*/

for(var i = 0; i < 10; i++) {
    // 문 실행
}

/** 
 * ? 반복문의 조건이 되는 조건식을 맨 왼쪽에서 초기화 한다. -> var i = 0;
 * ? 문을 실행한 다음 맨 오른쪽 증감식을 통해 증감을 진행
 * ? 왼쪽 값을 조건식과 비교하여 false 가 나올 때까지 반복
 * ! 무한 루프를 사용하고 싶을 땐 저 세 개의 옵션중 하나라도 빠지면 무한루프가 된다.
*/

for (var one = 1; one <= 6; one++) {
    for (var two = 1; two <= 6; two++) {
        console.log(`Dice : [${one}, ${two}]`);
    }
}

/** 
 * ? for문 안의 for문을 넣을 수 있다. 이중 삼중 사중 가능하다. 
*/


/** 
 * * while 문 
*/

var coin = 10; 

while(coin > 0) {
    console.log("you dead!");
    coin--;
}

/** 
 * ? while문은 조건식 평가값이 참이면 문을 계속해서 실행한다.
 * ? 블록문 자체에서 조건식이 거짓이 될 만한 코드를 따로 추가시켜야 탈출할  수 있다.
 * ? for은 미리 정하지만 while은 문에서 제어해야한다.
 * ? 반복문을 탈출하기 위해선 조건식이 거짓이 되거나 break문으로 탈출한다.
*/

coin = 10;

while(coin > 0) {
    console.log("you dead!");
    coin--;

    if(coin == 4) {
        console.log('you win!');
        break;
    }
}

/** 
 * ? if 문을 통해 조건을 구하고 break로 빠져나옴.
*/


/** 
 * * do while문
 * ? do 라는 뭔가를 하겠다 라는 뜻이다.
 * ? while문은 조건식이 처음부터 거짓이면 문을 실행조차 하지 않는데 비해
 * ? 이 문은 do 처럼 한번 문을 실행한 뒤에 조건식을 평가한다.
*/

coin = 0;

do {
    console.log('do you have coin?');
} while(coin > 0);

/** 
 * ? 코인으 없지만 do문으로 코인이 있는지 확인하는 코드를 작성했다.
 * ? 조건이 거짓이라 반복되진 않는다.
*/


/** 
 * ! break 
 * ? break는 위에서 사용한듯이 코드 블록을 탈출하는 기능을 갖고있다.
 * ? 그러나 일반적인 코드 블록문을 탈출하는 것이 아닌
 * ? 반복문,switch문,레이블 문 에서만 블록문을 탈출할 수 있다.
 * ? 그 외에는 에러가 뜬다.
*/

/** 
 * * 레이블 문 
 * ? 위에서 설명한 여러 문들을 구별하기 위해 식별자를 붙인 문이다. 
*/

label : console.log('label'); // 모든 문에 식별자를 붙일 수 있다. 근데 왜 붙이는 거지? 알고보니 case문도 레이블 문 이었다.

escape : {
    break escape;
}

/** 
 * ? 기존의 블록문을 break를 사용할 수 없지만 레이블을 등록하면 
 * ? break를 사용할 수 있다. switch case의 경우를 제외하곤,
 * ? break 다음 레이블 이름을 적어줘야 한다.
*/

/** 
 * * continue 문
 * ? 반복문의 모든 문을 실행하지 않고 특정 문을 실행하고 다음으로 넘기고 싶을때
 * ? 이 continue 를 사용한다. 사용하게 되면 바로 현재 작동 시점에서 중단하고 증감식으로 이동한다.
*/

var traveler = ["germany","korea","spain","usa"]; // 입국 검사인데 한국인은 건너뛰는 이상한 검사

for(var i = 0; i < traveler.length; i++) {
    
    if(traveler[i] === "korea") continue;

    console.log(`your country? : ${traveler[i]}`);
}

// 한국인은 건너뛰는 코드를 작성했다.



